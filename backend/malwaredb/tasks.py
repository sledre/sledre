import errno
import os
import zipfile

from shutil import rmtree
from celery import shared_task
from textwrap import wrap
from rest_framework.renderers import JSONRenderer

from malwaredb.models import Malware, MalwareState
from malwaredb.serializers import MalwareSerializer


def zipdir(path, ziph):
    for root, dirs, files in os.walk(path):
        for file in files:
            ziph.write(
                os.path.join(root, file),
                os.path.relpath(os.path.join(root, file), os.path.join(path, "..")),
            )


@shared_task(bind=True)
def generate_dataset(self):
    # Here we use the task id so we can download the file asynchronously
    task_id = self.request.id.__str__()
    dataset_dir = "/data/datasets/" + task_id
    # Create the working directory
    try:
        os.mkdir(dataset_dir)
    except OSError:
        print("Creation of the directory %s failed" % dataset_dir)
    else:
        print("Successfully created the directory %s " % dataset_dir)

    # Create the dataset directory that contains the db object serialized
    for malware in Malware.objects.filter(state=MalwareState.DONE):
        dirs = wrap(malware.sha256, 2)
        malware_export = JSONRenderer().render(MalwareSerializer(malware).data)

        path = dataset_dir + "/" + "/".join(dirs[:5]) + "/" + malware.sha256 + ".json"
        if not os.path.exists(os.path.dirname(path)):
            try:
                os.makedirs(os.path.dirname(path))
            except OSError as exc:
                if exc.errno != errno.EEXIST:
                    raise
        try:
            with open(path, "wb") as fd:
                fd.write(malware_export)
        except:
            pass

    # Create a zip file from the previous dataset
    zipf = zipfile.ZipFile(
        "/data/datasets/" + task_id + ".zip", "w", zipfile.ZIP_DEFLATED
    )
    zipdir(dataset_dir, zipf)
    zipf.close()

    # Remove the dataset creation directory and keep the zip file
    rmtree(dataset_dir)
